# · html5 新特性、语义化
· 语义化标签： header nav main article section aside footer

语义化意味着顾名思义，HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构，如 
header,footer,nav，从标签上即可以直观的知道这个标签的作用，而不是滥用div。
语义化的优点有:
代码结构清晰，易于阅读，利于开发和维护
方便其他设备解析（如屏幕阅读器）根据语义渲染网页。
有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重

## 1. 浏览器渲染机制、重绘、重排（回流）

**网页生成过程**

- `HTML`被HTML解析器解析成`DOM`树
- `css`则被css解析器解析成`CSSOM`树
- 结合`DOM`树和`CSSOM`树
- 生成布局（`flow`）, 即将所有渲染树的所有结点进行平面结合
- 将布局重回（`paint`）在屏幕上

**重排（回流）**

​		当`DOM`的变化影响了元素的几何信息（`DOM`对象的位置和尺寸大小），浏览器需要重新计算元素的几何属性，将其安放在界面正确的位置，这个过程叫做回流。触发条件：

1. 添加或者删除可见DOM元素
2. 元素尺寸改变 ----边距、填充、边框、宽度和高度

**重绘**

​		当一个元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫重绘。

- 改变元素的 `color`、`background`、`box-shadow` 等属性

重排优化建议：

1. 分离读取操作
2. 样式集中修改
3. 缓存需要修改的`DOM`元素
4. 尽量只修改`position: absolute`或`fixed`元素， 对其他元素影像不大
5. 动画开始`GPU`加速， `translate` 使用 `3D`变化

`transform`不重绘，不回流，是因为`transform`属于合成属性，对合成属性进行`transition/animate`动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧。

## CSS盒子模型

​		所有`HTML`元素可以看作盒子，在CSS中，`"box model"`这一术语是用来涉及和布局时使用。`CSS`盒模型本质是一个盒子，封装周围的`HTML`元素，它包括：边距、边框、填充和实际内容。盒模型允许我们在其他元素和周围元素边框之间的空间放置。

## CSS样式优先级

`!important>style>id>class`

## DOM、BOM对象

​		`BOM（Browser Object Model）`是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用BOM， 开发者可以移动窗口、改变状态栏中的文本以及执行其他余页面内容不直接相关的动作。使`JavaScript`有能力与浏览器“对话”。

​		`DOM(Document Object Model)`是指文档对象模型，通过它，可以访问`HTML`文档的所有元素。`DOM`是`W3C`标准。`DOM`定义了访问`HTML`和`XML`文档标准。

什么是`XML DOM`? `XML DOM`定义了所有XML元素的对象和属性， 以及访问他们的方法。

# · JS 相关

## 1.js数据类型、typeof、instanceof、类型转换

1. `string、number、boolean、null、undefined、object(function array)、symbol(ES10BigInt)`
2. `typeof`主要用来判断数据类型 返回值有`string、boolean、number、function、object、undefined`
3. `instanceof`判断该对象是谁的实例
4. `null`表示空对象`undefined`表示已在作用域中声明但为赋值的变量



## 2.闭包

闭包是指有权访问另一个函数作用域中的变量的函数。

当函数可以记住并访问所在的词法作用域时， 就产生了闭包，即使函数是在当前词法作用域之外执行。

- 闭包用途：

1. 能访问函数定义时所在的词法作用域（阻止其被回收）
2. 私有化变量
3. 模拟块级作用域
4. 创建模块

- 闭包缺点： 会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏

## 3.原型、原型链

**原型：** 对象中固有的`__proto__`属性， 该属性指向对象的`prototype`原型属性。

**原型链：**当我们访问一个对象属性时，如果这个对象内部不存在这个属性，它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。 原型链的尽头一般来说是`Object.prototype`所以这就是我们新建的对象为什么能够使用`toString()`等方法的原因。

**特点：**`JavaScript`对象是通过引用来传递的，我们创建的每一个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

## 4.this指向、new关键字

`this`对象是执行上下文中的一个属性，它指向最后一次调用这个方法的对象，在全局函数中，`this`等于`window`，而

当函数呗作为某个对象调用时，this等于那个对象。在实际开发中，`this`的指向可以通过4种调用模式来判断。

1. 函数调用，当一个函数不是一个对象属性时，直接作为函数来调用时，`this`指向全局对象。
2. 方法调用，如果一个函数作为一个对象的方法来调用时，`this`指向这个对象。
3. 构造函数调用，`this`指向这个用`new`新创建的对象。
4. `apply、call、bind`调用模式，这三个方法都可以显示指定调用函数的this指向。`apply`接收参数是数组。`call`接受参数列表， `bind`方法通过传入一个对象，返回`this`绑定了传入对象的新函数。这个函数的`this`指向除了使用`new`时会发生改变，其他情况下都不会改变。

**new**

1. 首先创建一个新的空对象
2. 设置原型，将对象的原型设置为函数的`prototype`对象
3. 让函数的`this`指向这个对象，执行构造函数的代码（为这个新对象添加属性）
4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

## 作用域、作用域链、变量提升

​		`作用域`负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。（全局作用域、函数作用域、块级作用域）。作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是`作用域链`。

## 继承

1. 以`原型链的方式来实现继承`， 缺点： 在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱；还有创建子类型的时候不能向超类型传递参数。
2. `借用构造函数`的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型定义的方法子类型也没有办法访问到。
3. `组合继承`，将原型链和借用构造函数组合在一起使用。通过借用构造函数的方法实现类型的属性继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方法解决了上面两种模式单独使用时的问题，但由于我们是以超类型的实例来作为子类型的原型，所有调用用了两次超类的构造函数，造成子类型的原型中多了很多不必要的属性。
4. `原型式继承`，原型式继承是主要思路就是给予已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承实录主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5中定义的Object.create()方法就是原型式继承的实现，缺点余原型链方法相同。
5. `寄生式继承`，寄生式继承思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就是可以理解是一种继承。这种继承的有点就是对简单对象实现继承，如果这个对象不是我们自定义类型时。缺点是没有办法实现函数的服用。
6. `寄生式组合继承`，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致了不必要的原型属性。季胜师组合继承的方法是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。

## EventLoop

​		`JS`是单线程的， 为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先与宏任务队列。 微任务队列的代表就是`Promise.then`,`MutationObserver`，宏任务的话就是`setImmediate setTimeout setInterval`

## 原生ajax

​		**ajax**是一种异步通信的方法，从服务端获取数据，达到局部刷新页面的效果。过程：

1. 创建`XMLHttpRequest`对象
2. 调用`open`方法传入三个参数，请求方式`(GET/POST)、url、同步异步(true/false)`
3. 监听`onreadystatechange`事件，当`readystate`等于4时返回`responseTest`
4. 调用send方法传递参数

## 事件冒泡、捕获（委托）

- **事件冒泡**指在一个对象上触发某类事件，如果此对象绑定了事件，就会触发事件。如果没有，就会向这个对象的父级对象传递，最终父级对象触发了该事件。
- **事件委托**本质上是利用了浏览器事件冒泡机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以吧子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。

`event。stopPropagetion()`或者ie下的方法`event.cancelBubble = true` // 阻止事件冒泡

## ES6

1. 新增symbol类型 表示独一无二的值，用来定义独一无二的对象属性名
2. const/let 都是用来声明变量，不可重复声明，具有块级作用域。存在暂时性死区，也就是不存在变量提升。（const 一版用于声明常量）
3. 解构赋值（包括数组、对象、字符串、数字及布尔值，函数参数），剩余运算符（...rest）
4. 模板字符串（${data}）
5. 扩展运算符（数组、对象）
6. 箭头函数
7. set和map数据结构
8. Proxy/Reflect
9. promise
10. async函数
11. Class
12. Module语法（import/export）

# Vue

## 简述MVVM

​		**MVVM**是`Model-View-ViewModel`缩写，也就是把`MVC`中的`Controller`演变成`ViewModel`。`Model`层代表数据模型，`View`代表UI组件，`ViewModel`是`View`和`Model`层的桥梁，数据会绑定到`viewModel`层并自动将数据渲染到页面中，视图变化的时候会通知`viewModel`层更新数据。

## 谈谈对Vue生命周期的理解？

​		每个`Vue`实例在创建时都会经过一系列的初始化过程，`vue`的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件。

- `create阶段`： vue实例被创建`beforeCreate`创建前，此时data和methods中的数据都还没有初始化`created`创建完毕，data中有值，未挂载
- `mount阶段`：vue实例呗挂载到真实DOM节点`beforeMount`可以发起服务器请求，去数据`mounted`此时可以操作DOM
- `update阶段`：当vue实例里面的data数据变化时，触发组件的重新渲染`beforeUpdate` `updated`
- `destroy阶段`：vue实例被销毁 `beforeDestroy`实例被销毁前，此时可以手动销毁一些方法`destroyed`

## computed与watch

**watch属性监听**是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，监听属性的变化，需要在数据变化时执行异步或开销较大的操作使用。

**computed计算属性**该属性的结果会被缓存，当`computed`中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用`computed`中的函数必须用`return`返回最终的结果，`computed`更高效，优先使用

**使用场景**`computed`当一个属性受多个属性影响的时候使用，例：购物车结算功能； `watch`当一条数据影响多条数据的时候使用，例：搜索数据。

## v-for中key的作用

1. `key`的作用主要是为了更高效的对比虚拟DOM中每个节点是否相同节点。
2. vue在`patch`过程中判断两个节点是否是相同节点，key是一个必要条件，渲染一组列表时，key往往是唯一标识，所以如果不定义keyy的话，`vue`只能任务比较的两个节点是同一个，哪怕他们实际上不是，这导致了平凡更新元素，是的整个patch过程比较低效，影响性能。
3. 从源码中可以知道，Vue判断两个节点是否相同时，主要判断两者的key和元素类型等，因此如果不设置key，它的值就是`undefined`,则可能永远认为这是两个相同的节点，只有去做更新操作，这造成了大量的dom更新操作，明显是不可取的。

Vue组件的通信方法























































