# · html5 新特性、语义化
· 语义化标签： header nav main article section aside footer

语义化意味着顾名思义，HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构，如 
header,footer,nav，从标签上即可以直观的知道这个标签的作用，而不是滥用div。
语义化的优点有:
代码结构清晰，易于阅读，利于开发和维护
方便其他设备解析（如屏幕阅读器）根据语义渲染网页。
有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重

## 1. 浏览器渲染机制、重绘、重排（回流）

**网页生成过程**

- `HTML`被HTML解析器解析成`DOM`树
- `css`则被css解析器解析成`CSSOM`树
- 结合`DOM`树和`CSSOM`树
- 生成布局（`flow`）, 即将所有渲染树的所有结点进行平面结合
- 将布局重回（`paint`）在屏幕上

**重排（回流）**

​		当`DOM`的变化影响了元素的几何信息（`DOM`对象的位置和尺寸大小），浏览器需要重新计算元素的几何属性，将其安放在界面正确的位置，这个过程叫做回流。触发条件：

1. 添加或者删除可见DOM元素
2. 元素尺寸改变 ----边距、填充、边框、宽度和高度

**重绘**

​		当一个元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫重绘。

- 改变元素的 `color`、`background`、`box-shadow` 等属性

重排优化建议：

1. 分离读取操作
2. 样式集中修改
3. 缓存需要修改的`DOM`元素
4. 尽量只修改`position: absolute`或`fixed`元素， 对其他元素影像不大
5. 动画开始`GPU`加速， `translate` 使用 `3D`变化

`transform`不重绘，不回流，是因为`transform`属于合成属性，对合成属性进行`transition/animate`动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧。

## CSS盒子模型

​		所有`HTML`元素可以看作盒子，在CSS中，`"box model"`这一术语是用来涉及和布局时使用。`CSS`盒模型本质是一个盒子，封装周围的`HTML`元素，它包括：边距、边框、填充和实际内容。盒模型允许我们在其他元素和周围元素边框之间的空间放置。

## CSS样式优先级

`!important>style>id>class`

## DOM、BOM对象

​		`BOM（Browser Object Model）`是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用BOM， 开发者可以移动窗口、改变状态栏中的文本以及执行其他余页面内容不直接相关的动作。使`JavaScript`有能力与浏览器“对话”。

​		`DOM(Document Object Model)`是指文档对象模型，通过它，可以访问`HTML`文档的所有元素。`DOM`是`W3C`标准。`DOM`定义了访问`HTML`和`XML`文档标准。

什么是`XML DOM`? `XML DOM`定义了所有XML元素的对象和属性， 以及访问他们的方法。

# · JS 相关

## 1.js数据类型、typeof、instanceof、类型转换

1. `string、number、boolean、null、undefined、object(function array)、symbol(ES10BigInt)`
2. `typeof`主要用来判断数据类型 返回值有`string、boolean、number、function、object、undefined`
3. `instanceof`判断该对象是谁的实例
4. `null`表示空对象`undefined`表示已在作用域中声明但为赋值的变量



## 2.闭包

闭包是指有权访问另一个函数作用域中的变量的函数。

当函数可以记住并访问所在的词法作用域时， 就产生了闭包，即使函数是在当前词法作用域之外执行。

- 闭包用途：

1. 能访问函数定义时所在的词法作用域（阻止其被回收）
2. 私有化变量
3. 模拟块级作用域
4. 创建模块

- 闭包缺点： 会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏

## 3.原型、原型链

**原型：** 对象中固有的`__proto__`属性， 该属性指向对象的`prototype`原型属性。

**原型链：**当我们访问一个对象属性时，如果这个对象内部不存在这个属性，它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。 原型链的尽头一般来说是`Object.prototype`所以这就是我们新建的对象为什么能够使用`toString()`等方法的原因。

**特点：**`JavaScript`对象是通过引用来传递的，我们创建的每一个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

## 4.this指向、new关键字

`this`对象是执行上下文中的一个属性，它指向最后一次调用这个方法的对象，在全局函数中，`this`等于`window`，而

当函数呗作为某个对象调用时，this等于那个对象。在实际开发中，`this`的指向可以通过4种调用模式来判断。

1. 函数调用，当一个函数不是一个对象属性时，直接作为函数来调用时，`this`指向全局对象。
2. 方法调用，如果一个函数作为一个对象的方法来调用时，`this`指向这个对象。
3. 构造函数调用，`this`指向这个用`new`新创建的对象。
4. `apply、call、bind`调用模式，这三个方法都可以显示指定调用函数的this指向。`apply`接收参数是数组。`call`接受参数列表， `bind`方法通过传入一个对象，返回`this`绑定了传入对象的新函数。这个函数的`this`指向除了使用`new`时会发生改变，其他情况下都不会改变。

**new**

1. 首先创建一个新的空对象
2. 设置原型，将对象的原型设置为函数的`prototype`对象
3. 让函数的`this`指向这个对象，执行构造函数的代码（为这个新对象添加属性）
4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

## 作用域、作用域链、变量提升

​		`作用域`负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。（全局作用域、函数作用域、块级作用域）。作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是`作用域链`。

## 继承

1. 以`原型链的方式来实现继承`， 缺点： 在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱；还有创建子类型的时候不能向超类型传递参数。
2. `借用构造函数`的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型定义的方法子类型也没有办法访问到。
3. `组合继承`，将原型链和借用构造函数组合在一起使用。通过借用构造函数的方法实现类型的属性继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方法解决了上面两种模式单独使用时的问题，但由于我们是以超类型的实例来作为子类型的原型，所有调用用了两次超类的构造函数，造成子类型的原型中多了很多不必要的属性。
4. `原型式继承`，原型式继承是主要思路就是给予已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承实录主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5中定义的Object.create()方法就是原型式继承的实现，缺点余原型链方法相同。
5. `寄生式继承`，寄生式继承思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就是可以理解是一种继承。这种继承的有点就是对简单对象实现继承，如果这个对象不是我们自定义类型时。缺点是没有办法实现函数的服用。
6. `寄生式组合继承`，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致了不必要的原型属性。季胜师组合继承的方法是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。

## EventLoop

​		`JS`是单线程的， 为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先与宏任务队列。 微任务队列的代表就是`Promise.then`,`MutationObserver`，宏任务的话就是`setImmediate setTimeout setInterval`

## 原生ajax

​		**ajax**是一种异步通信的方法，从服务端获取数据，达到局部刷新页面的效果。过程：

1. 创建`XMLHttpRequest`对象
2. 调用`open`方法传入三个参数，请求方式`(GET/POST)、url、同步异步(true/false)`
3. 监听`onreadystatechange`事件，当`readystate`等于4时返回`responseTest`
4. 调用send方法传递参数

## 事件冒泡、捕获（委托）

- **事件冒泡**指在一个对象上触发某类事件，如果此对象绑定了事件，就会触发事件。如果没有，就会向这个对象的父级对象传递，最终父级对象触发了该事件。
- **事件委托**本质上是利用了浏览器事件冒泡机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以吧子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。

`event。stopPropagetion()`或者ie下的方法`event.cancelBubble = true` // 阻止事件冒泡

## ES6

1. 新增symbol类型 表示独一无二的值，用来定义独一无二的对象属性名
2. const/let 都是用来声明变量，不可重复声明，具有块级作用域。存在暂时性死区，也就是不存在变量提升。（const 一版用于声明常量）
3. 解构赋值（包括数组、对象、字符串、数字及布尔值，函数参数），剩余运算符（...rest）
4. 模板字符串（${data}）
5. 扩展运算符（数组、对象）
6. 箭头函数
7. set和map数据结构
8. Proxy/Reflect
9. promise
10. async函数
11. Class
12. Module语法（import/export）

# ·Vue

## 简述MVVM

​		**MVVM**是`Model-View-ViewModel`缩写，也就是把`MVC`中的`Controller`演变成`ViewModel`。`Model`层代表数据模型，`View`代表UI组件，`ViewModel`是`View`和`Model`层的桥梁，数据会绑定到`viewModel`层并自动将数据渲染到页面中，视图变化的时候会通知`viewModel`层更新数据。

## 谈谈对Vue生命周期的理解？

​		每个`Vue`实例在创建时都会经过一系列的初始化过程，`vue`的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件。

- `create阶段`： vue实例被创建`beforeCreate`创建前，此时data和methods中的数据都还没有初始化`created`创建完毕，data中有值，未挂载
- `mount阶段`：vue实例呗挂载到真实DOM节点`beforeMount`可以发起服务器请求，去数据`mounted`此时可以操作DOM
- `update阶段`：当vue实例里面的data数据变化时，触发组件的重新渲染`beforeUpdate` `updated`
- `destroy阶段`：vue实例被销毁 `beforeDestroy`实例被销毁前，此时可以手动销毁一些方法`destroyed`

## computed与watch

**watch属性监听**是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，监听属性的变化，需要在数据变化时执行异步或开销较大的操作使用。

**computed计算属性**该属性的结果会被缓存，当`computed`中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用`computed`中的函数必须用`return`返回最终的结果，`computed`更高效，优先使用

**使用场景**`computed`当一个属性受多个属性影响的时候使用，例：购物车结算功能； `watch`当一条数据影响多条数据的时候使用，例：搜索数据。

## v-for中key的作用

1. `key`的作用主要是为了更高效的对比虚拟DOM中每个节点是否相同节点。
2. vue在`patch`过程中判断两个节点是否是相同节点，key是一个必要条件，渲染一组列表时，key往往是唯一标识，所以如果不定义keyy的话，`vue`只能任务比较的两个节点是同一个，哪怕他们实际上不是，这导致了平凡更新元素，是的整个patch过程比较低效，影响性能。
3. 从源码中可以知道，Vue判断两个节点是否相同时，主要判断两者的key和元素类型等，因此如果不设置key，它的值就是`undefined`,则可能永远认为这是两个相同的节点，只有去做更新操作，这造成了大量的dom更新操作，明显是不可取的。

## Vue组件的通信方法

### 父子组件通信

父 -> 子 `props`， 子 -> 父 `$on、$emit` 获取父子组件实例， `parent、children、Ref` 获取实例的方式调用组件的属性或者方法。 `provide、inject`官方不推荐使用，但是写组件库时很常用。

### 兄弟组件通信

`Event Bus` 实现跨组件通信 `Vue.prototype.#bus = new Vue() Vuex`

### 跨级组件通信

`$attrs、 $listeners` 丨 `provide、inject`

## 常用指令

- v-if： 判断是否加载
- v-show：判断是否隐藏
- v-for：数据循环出来
- v-bind:class：绑定一个属性
- v-model：实现双向绑定

## 双向绑定实现原理

当一个Vue实现创建时，Vue会遍历data选项的属性，用`Object.defineProperty`将它们转化为`getter/setter`并且在内部追踪相关依赖，在属性被访问拒绝和修改时通知变化。每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。

## v-model的实现以及它的实现原理吗？

1. `vue`中双向绑定是一个指令`v-model`，可以绑定一个动态值到视图，同时视图中变化能改变该值。`v-model`是语法糖，默认情况下相当于：`value@input`。
2. 使用`v-model`可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好
3. 通畅在表单项上使用`v-model`
4. 原生的表单项可以直接使用`v-model`，自定义组件上如果使用它需要在组件内绑定value并处理输入事件
5. 输入包括`v-model`模板的组件渲染函数，发现它会被转化为value属性的绑定，以及一个事件监听，事件回调函数中会做相应变量更新操作。

## nextTick 实现原理

1. `nextTick`是`Vue`提供的一个全局`API`，是下次`DOM`更新循环结束之后执行延时回调，在修改之后使用`$nextTick`，则可以再回调中获取更新后的`DOM`
2. vue在更新DOM时是异步执行的。只要侦听到数据变化，`vue`将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个`watcher`被多次触发，只会推入到队列中1次。这种在缓冲时去除重复数据对于避免不必要的计算和`DOM`操作非常重要的。`nextTick`方法会在队列中加入一个回调函数，确保该函数在前面的`DOM`操作完成后才调用。
3. 比如， 我在干什么的时候会使用`nextTick`，传入一个回调函数进去，在里面执行`DOM`操作
4. `nextTick`实现，它会在`callbacks`里面加入我们传入的函数，然后用`timerFunc`异步方式调用它们，首选的异步方法会是`Promise`。

## new Vue 后整个流程

- `initProxy`：作用域代理，拦截组件内访问其他组件的数据；
- `initLifecycle`：建立父子组件关系，在当前组件实例上添加一些属性和生命周期标识。如`[Math Processing Error]parent, refs, $children, _issMounted`等；
- `initEvents`：对父组件传入的事件添加监听，事件是谁创建谁监听，子组件创建事件子组件监听；
- `initRender`：声明[Math Processing Error]slots和slots和createElement()等；
- `initInjections`：注入数据，初始化inject，一般用于组件更深层次之间的通信；
- `initState`：重要）数据响应式：初始化状态。很多选项初始化的汇总：data,methods,props,computed,watch；
- `initProvide`：提供数据注入。

**思考：为什么先注入再提供呢？**

答：

1. 首先来着祖辈的数据要当前实例的`data`等判重，相结合，所以注入数据的`initInjections`一定要在`InitState`的上面。

		2. 从上面注入进来的东西在当前组件中转了一下又提供给后代了，所以注入的数据也一定在上面。

`vm.[Math Processing Error]mount(vm.mount(vm.options.el))`：挂载实例。

## keep-alive的实现

作用：实现组件缓存

**钩子函数：**

`activated`组件渲染后调用

`deactuvated`组件销毁后调用

原理：`Vue.js`内部将`DOM`节点抽象成一个个的`VNode`节点，`keep-alive`组件的缓存也是基于`VNode`节点的而不是直接储存`DOM`结构。它将满足条件`(pruneCache与pruneCache)`的组件在`cache`对象中缓存起来，在需要重新重新渲染的时候再将`VNode`节点从`cache`对象中取出并渲染。

**配置属性：**

`include`字符串或正则表达式。只有名称匹配的组件会被缓存

`exclude`字符串或正则表达式。任何名称匹配的组件都不会被缓存

`max`数字、最多可以缓存多少组件实例

## vuex、vue-router实现原理

`vuex`是一个专门为vue.js应用程序开发的状态管理库。核心概念：

- `state`(单一状态树)`getter/Mutation`显示提交更改`state`；
- `Action类似Mutation`，可以包含任何异步操作；
- `module`(当应用变得庞大复杂，拆分`store`为具体的`module`模块)

## 如何理解Vue中的diff算法？

在js中，渲染真是`DOM`的开销是非常大的，比如我们修改了某个数据，如果直接渲染到真实`DOM` ,会引起整个`DOM`树重绘和重排。那么有没有可能实现只更新我们修改的那一小块`DOM`二不要更新整个`DOM`呢?此时我们就需要先根据真实`DOM`生成虚拟`DOM`，当虚拟`DOM`某个节点的数据改变后会生成有一个新的`VNode`，然后新的`VNode`和旧的`VNode`作比较，发现有不一样的地方就直接修改在真实DOM上，然后旧的`VNode`的值为新的`VNode`；

**diff**的过程就是调用`patch`函数，比较新旧节点，一边比较一边给真实的`DOM`打补丁，在采用`diff`算法比较新旧节点的时候，比较自会在同层级进行。在`patch`方法中，首先进行树级别的比较`new Vnode`不存在就删除`old VNode`，`old VNode`不存在就增加新的`VNode`都存在就执行`diff`更新，当确定需要执行`diff`算法时，比较两个`VNode`，包括三种类型操作：属性更新，文本更新，子节点更新，新老节点均有子节点，则对子节点进行`diff`操作，调用`updatechidren`如果老节点没有子节点，先清空老节点的文本内容，然后为其新增子节点，如果新节点没有子节点，而老节点有子节点的时候，则移除该节点的所有子节点，老节点都没有子节点的时候，进行文本的替换。

**updateChildren**将`VNode`的子节点Vch和oldVNode提取出来。`oldCh和VCh`各有两个头尾的变量`StartId和EnIdx`它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没有匹配，如果设置了key，就会用`key`进行比较，在比较过程中，变量会往中间靠，一旦`StartIdx>EndIdx`表明`oldCh和VCh`至少有一个已经遍历完了，就会结束比较。

## 你都做过哪些Vue的性能优化？

```
编码阶段
尽量减少data中的数据，data中的数据都会增加getter和setter,会收集对应的watcher
v-if 和 v-for 不能连用
如果需要使用v-for 给每个原始绑定事件时，使用事件代理
SPA页面采用keep-live缓存组件
在更多的情况下，使用v-if代替v-show
key保证唯一
使用路由懒加载、异步组件
防抖、节流
第三方模块按需导入
长列表滚动到可视区域动态加载
图片懒加载
SEO优化
预渲染
服务端渲染SSR
打包优化
压缩代码
Tree Shaking/Scope Hoisting
使用cdn加载第三方模块
多线程打包happypack
splitChunks 抽离公共文件
sourceMap优化
用户体验
骨架屏
PWA
还可以使用缓存（客户端缓存、服务端缓存）优化、服务端开启gzip压缩等。
```

## Vue有哪些新特性吗？它们会带来什么影响？

- 性能提升

  更小巧、更快速。支持自定义渲染器，支持摇树优化：一种在打包时去除无用代码的优化手段，支持Fragments和跨组件渲染

- API变动

  模板语法99%保持不变，原生支持基于class组件，并且无需借助任何编译及各种stage阶段的特性，在设计时也考虑TypeScript的类型推断特性`重写虚拟DOM`可以期待更多的编译时提示来减少运行时的开销`优化插槽生成`可以单独渲染父组件和子组件`静态树提示`降低渲染成本`基于Proxy的观察者机制`节省内存开销。

- 不兼容IE11

  `检测机制`更加全面、精准、高效，更具可调试的相应跟踪

## 实现双向绑定Proxy与Object.defineProperty相比优劣势？

1. **Object.definedProperty**的作用是劫持一个对象的属性，劫持属性的getter和setter方法，在对象属性发生变化时进行特定的操作。而Proxy劫持是整个对象。
2. **Proxy**会返回一个代理对象，我们只需要操作新对象即可，而Object.definedProperty只能遍历对象属性直接修改
3. **Object.definedProperty**不支持数组，更精确的说是不支持数组的各种API，因为如果仅考虑array[i]=Value这种情况，是可以劫持的，但这种劫持意义不大。而Proxy可以支持数组的各种API。
4. 尽管Object.definedProperty有诸多缺陷，但其兼容性要好于Proxy。



# · React

## react中的key的作用，有key和没key有什么区别，比较同一层级节点什么意思

Keys是React用于追踪哪些列表元素被修改，被添加或者被移除的辅助标识。

## 你对虚拟dom和diff算法的理解，实现render函数

`虚拟DOM`本质上是`JavaScript`对象，是对`真实DOM`的抽象表现。状态变更时，记录新树和旧树的差异，最后把差异更新到真正的`dom`中**render函数**

1. 根据`tagName`生成父标签，读取props，设置属性， `如果有content`，设置`innerHtml或innerText`；
2. 如果存在子元素，遍历子元素递归调用render方法，将生成的子元素依次添加到父元素中，并返回根目录；

## React组件之间通信方式？

1. 父子组件， 父>子直接用`props`，子>父用`callback`回调；

2. 非父子组件，用发布订阅模式的`event`模块；

3. 项目复杂的话用`redux、Mobx`等全局状态管理库；

4. `context Api context`会使组件复用性变差；

   `context`提供了一个无需为每层组件手动添加`props`，能够在组件树间进行数据传递的方法，如果你只是向避免层层传递一些属性，组件组合(`component composition`)有时候是一个比context更好的解决方案；

5. 组件组合缺点：会使高层组件变得复杂；

## 如何解析jsx

调用react.createElement函数创建对象

## 生命周期都有哪几种，分别在什么阶段做哪些事情？为什么要废弃一些生命周期？

componentWillMount、componentWillReceiveProps、componentWillUpdate在16版本被废弃，在17版本将被删除，需要使用UNSAVE_前缀使用，目的是向下兼容。

## 关于react的优化方法

- 代码层面：

  使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。

- props和state的数据尽可能简单明了，扁平化。

  不要使用数组下标作为key
  利用 shouldComponentUpdate 和 PureComponent 避免过多 render function;
  render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。
  尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将 component 当作 props 传入

- 代码体积：

  使用 babel-plugin-import 优化业务组件的引入，实现按需加载
  使用 SplitChunksPlugin 拆分公共代码
  使用动态 import，懒加载 React 组件

## 绑定this的几种方式

bind/箭头函数

## 对fiber的理解

react fiber 是一种基于浏览器的单线程调度算法

# ·Vue与React对比

## 数据流

**react**主张函数式编程，所以推崇纯组件，数据不可变，单向数据流。

**vue**的思想是相应式的，也就是基于是数据可变的，通过对每一个属性建立watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。

### 监听数据变化实现原理

- `vue`通过`getter/setter`以及一些函数的劫持，能精确知道数据变化，不需要特别的优化能达到很好的性能。
- 































































